# 字符串相关

## 字符串方法合集（进阶版）

1. **对多个子串的替换**

    ```python
    # 针对多个子串的替换 
    # 法一
    for ch in " \n\r\t":
        s = s.replace(ch, '')
    # 法二 （更快）
    s = s.translate(str.maketrans({'\n': '', '\t': '', ' ':'', '\r': ''}))
    ```

2. **去除一个字符串里所有空格的另一种思路**：

    ```python
    s = "11 22 33 44"    # 一些情况可以用
    s = ''.join(s.split(' '))
    ```

    

## python 正则表达式

---------

------

### 基础知识

--------

正则表达式（Regular Expressions），通常是指一种特殊的文本模式，用于在文本中搜索、匹配和操作字符串。

1. **匹配文本模式：** 正则表达式可以用于查找文本中特定的模式。这可以包括查找特定的字符、词汇、数字、日期格式等。
2. **搜索和替换：** 正则表达式允许你搜索文本并替换符合特定模式的部分。你可以将匹配的文本替换为其他内容。
3. **提取信息：** 通过使用捕获组，你可以从匹配的文本中提取特定的部分，如电子邮件地址中的用户名和域名。
4. **验证数据：** 正则表达式用于验证输入数据是否符合特定的格式要求。例如，验证电子邮件地址、电话号码或密码的强度。

正则表达式是由字符和特殊符号组成的模式，这些字符和符号用于定义要匹配的文本模式。以下是一些常见的正则表达式元字符和符号：

- `^`: 匹配字符串开头

- `$`：匹配字符串的末尾

- `.`：匹配任意字符（除了换行符 `\n`）。

- `*`：匹配前导字符的零次或多次。

- `+`：匹配前导字符的一次或多次。

- `?`：匹配前导字符的零次或一次。

- `|`：用于表示或的关系，例如 `A|B` 匹配字符 A 或字符 B。

- `[]`：用于定义字符类，例如 `[abc]` 匹配字符 a、b 或 c。

- `[^]`：用于否定字符类，例如 `[^0-9]` 匹配任何非数字字符。

- `()`：用于创建**捕获组**，可以提取匹配的部分。

- `\d`：匹配数字字符，等同于 `[0-9]`。

- `\w`：匹配单词字符（字母、数字、下划线），等同于 `[a-zA-Z0-9_]`。

- `\s`：匹配空白字符（空格、制表符、换行符等）。

- `\b`：匹配单词边界。

    下面是一些**示例**：

    - `\bword\b` 匹配 "This is a word." 中的 "word"，但不匹配 "keywords" 中的 "word"。
    - `\b\d+\b` 匹配一个或多个数字组成的整数，确保匹配的是整个整数而不是数字的一部分。
    - `\b[A-Z]+\b` 匹配一个或多个大写字母组成的单词。

    `\b` 是一个非常有用的工具，特别是在需要匹配整个单词而不是部分字符时。它有助于确保正则表达式的精确性。



例如，以下是一些**正则表达式示例**：

- 匹配一个日期格式：`\d{4}-\d{2}-\d{2}`
- 匹配一个有效的电子邮件地址：`\b[\w._%+-]+@[\w.-]+\.[a-zA-Z]{2,4}\b`
- 匹配一个字符串末尾的数字部分：`\d+$`

正则表达式是一个强大但复杂的工具，需要一定的学习和实践来掌握。你可以使用Python的`re`模块来在Python中应用正则表达式，如前面的回答中所示。



### 使用原始字符串

------

**注意：使用原始字符串的好处**!!!  java里没有原生的原始字符串语法！！

在正则表达式中，前缀 `r` 表示一个"原始字符串"，它告诉Python解释器不要对字符串中的反斜杠进行转义处理。使用原始字符串的主要原因是，在正则表达式模式中经常会包含反斜杠 `\`，而 `\` 在普通字符串中通常被用于表示特殊字符，如换行符 `\n` 或制表符 `\t`。如果不使用原始字符串，那么需要使用两个反斜杠 `\\` 来表示一个单独的反斜杠 `\`，这会使正则表达式模式变得复杂。

使用原始字符串（`r` 前缀）的好处包括：

1. **简化正则表达式模式：** 使用原始字符串，你无需担心反斜杠的转义，因此可以更清晰地编写正则表达式。
2. **避免转义错误：** 如果你不使用原始字符串，那么当正则表达式模式中包含反斜杠时，你必须小心处理反斜杠的转义，以避免出现错误。

例如，考虑下面的正则表达式模式，它用于匹配包含反斜杠 `\` 的字符串：

```python
pattern = "\\w+\\\\\\d+"
```

使用原始字符串，你可以将其简化为：

```python
pattern = r"\w+\\\d+"
```

如你所见，使用原始字符串使正则表达式更易于理解和编写。所以，通常建议在编写正则表达式模式时使用原始字符串（带有 `r` 前缀）。



### 贪婪模式

------

在正则表达式中，默认情况下，量词（如 `*`、`+`、`?`、`{}` 等）是**贪婪**的，它们会尽可能多地匹配字符。如果你想关闭贪婪模式，可以在量词后面添加 `?`，这将使它们变为非贪婪模式。

例如，考虑以下正则表达式模式，它使用 `*` 量词来匹配文本中的 HTML 标签：

```python
pattern = r'<.*>'
```

在贪婪模式下，这个模式会匹配尽可能多的文本，从第一个 `<` 到最后一个 `>`，将整个文本作为一个匹配项。如果你想要非贪婪匹配，只匹配一个标签，你可以在 `*` 后面添加 `?`，如下所示：

```python
pattern = r'<.*?>'
```

这将匹配第一个 `<` 到第一个 `>` 之间的文本，然后停止，不再继续匹配后续的 `>`，使得匹配非贪婪。

<u>你可以将 `?` 添加到任何量词后面来关闭贪婪模式</u>。其他常见的量词包括 `+?`、`??` 和 `{n, m}?` 等。这些非贪婪模式通常在你需要匹配最小可能的文本时很有用。



## 如何在python中使用？ （re库）



### 基本方法

`re` 模块是Python中用于处理正则表达式的内置模块，提供了一系列方法用于匹配、搜索和操作字符串。以下是 `re` 模块的一些常用方法：

1. **`re.compile(pattern, flags=0)`**：
   - 用途：将正则表达式模式编译为正则表达式对象。
   - 参数：
     - `pattern`：要编译的正则表达式模式字符串。
     - `flags`：可选的标志，控制匹配模式的行为，例如忽略大小写匹配等。
   - 返回值：编译后的正则表达式对象，可以用于多次匹配。

   ```python
   import re
   pattern = re.compile(r'\d+')
   ```

2. **`re.match(pattern, string, flags=0)`**：
   - 用途：从字符串的开头开始匹配正则表达式模式。
   - 参数：
     - `pattern`：正则表达式模式。
     - `string`：要匹配的字符串。
     - `flags`：可选的标志。
   - 返回值：如果匹配成功，返回一个匹配对象；否则返回 `None`。

   ```python
   import re
   pattern = re.compile(r'\d+')
   match = pattern.match("123abc")
   ```

3. **`re.search(pattern, string, flags=0)`**：
   - 用途：在字符串中搜索匹配正则表达式模式的任何位置。
   - 参数：与 `re.match()` 相同。
   - 返回值：如果匹配成功，返回一个匹配对象；否则返回 `None`。

   ```python
   import re
   pattern = re.compile(r'\d+')
   match = pattern.search("abc123def")
   ```

4. **`re.findall(pattern, string, flags=0)`**：
   - 用途：查找字符串中的所有匹配项并返回它们作为列表
   
       **（如果有模式串有多个部分，列表的每个元素会是元组（相当于Match对象的group方法）,更加熟悉的感觉）**。

       **（没办法字典列表是唯一的劣势）**
   
   - 参数：与 `re.match()` 相同。
   
   - 返回值：包含所有匹配项的列表。

   ```python
   import re
   pattern = re.compile(r'\d+')
   matches = pattern.findall("The prices are $100, $50, and $75.")
   ```
   
5. **`re.sub(pattern, replacement, string, count=0, flags=0)`**：
   
   - 用途：使用指定的替换文本替换匹配的模式。
   - 参数：
     - `pattern`：正则表达式模式。
     - `replacement`：要替换匹配项的文本。
     - `string`：要搜索的字符串。
     - `count`：可选参数，限制替换的次数。
     - `flags`：可选的标志。
   - 返回值：返回替换后的字符串。
   
   ```python
   import re
   pattern = re.compile(r'\d+')
   new_text = pattern.sub('NUM', "The prices are $100, $50, and $75.")
   ```
   
5. **`re.finditer(pattern, string, flags=0)`**：
   
   - 用途：查找字符串中的所有匹配项并返回它们作为迭代器
   
       （**是 Match 对象的迭代器**，所以之后还是用 Match 对象的那套方法）。
   
   - 参数：与 `re.match()` 相同。
   
   - 返回值：包含所有匹配项的迭代器。
   
   ```python
    import re
    pattern = re.compile(r'\d+')
    matches = pattern.finditer("The prices are $100, $50, and $75.")
    for match in matches:
        print(match.group())
   ```
   
7. **`re.split(pattern, string, maxsplit=0, flags=0)`**：

    - 用途：使用正则表达式模式将字符串分割成多个子字符串。
    - 参数：
        - `pattern`：正则表达式模式，用于指定分割规则。
        - `string`：要分割的字符串。
        - `maxsplit`：可选参数，限制分割的次数。
        - `flags`：可选的标志。
    - 返回值：返回包含分割后子字符串的列表。

    ```python
    import re
    pattern = re.compile(r'\s+')
    words = pattern.split("Hello World")
    ```

    

这些方法是 `re` 模块中的一些常用函数，用于在Python中处理正则表达式。它们可用于搜索、匹配和操作文本，以及进行字符串替换和提取特定模式的文本。



### match 和 search 有什么区别？

>  `match` 从开头开始匹配，`search` + `^` 也可以实现从字符开头开始匹配
>
>  但是二者都只可以匹配一个

**从而：**

一般情况下，更常使用 `search` 函数而不是 `match`，因为 `search` 具有更广泛的用途。`search` 能够在整个字符串中查找与正则表达式模式匹配的位置，而不仅仅局限于字符串的开头。这使得 `search` 更加灵活，适用于许多不同的情况。

当你想要查找字符串中的任何位置的匹配时，或者当你不确定模式匹配的位置时，`search` 是一个更好的选择。它可以帮助你找到字符串中的多个匹配，而不仅仅是开头的匹配。

不过，有些情况下，如果你明确知道你只关心字符串开头的匹配，那么使用 `match` 也是有用的。例如，如果你想确保一个字符串以特定的模式开始，你可以使用 `match` 来验证。

总之，使用 `search` 或 `match` 取决于你的具体需求和匹配位置。一般情况下，`search` 更灵活，但在特定情况下，`match` 也有其用武之地。



### Group 相关

在Python的`re`模块中，正则表达式匹配成功后的匹配对象（通常是通过`match()`、`search()`等方法获得的对象）具有许多属性和方法，用于获取匹配的信息和文本。其中，与分组（捕获组）相关的属性和方法是非常有用的，它们允许你访问和操作匹配中的不同部分。

以下是与分组相关的主要属性和方法：

1. **`group([group1, ...])`**：
   - 用途：获取一个或多个分组（捕获组）的文本。
   - 参数：一个或多个分组的索引或名称。
   - 返回值：返回一个或多个分组的文本，如果未指定分组，将返回整个匹配的文本。

   示例：
   ```python
   import re
   pattern = re.compile(r'(\d{2})-(\d{2})-(\d{4})')
   match = pattern.search("Date: 12-31-2022")
   day = match.group(1)
   month = match.group(2)
   year = match.group(3)
   ```

2. **`groups(default=None)`**：
   - 用途：返回所有捕获组的元组。
   - 参数：可选参数，用于指定当没有匹配时的默认值。
   - 返回值：返回一个包含所有捕获组的文本的元组，如果没有匹配，返回指定的默认值。

   示例：
   ```python
   import re
   pattern = re.compile(r'(\d{2})-(\d{2})-(\d{4})')
   match = pattern.search("Date: 12-31-2022")
   day, month, year = match.groups()
   ```

3. **`groupdict(default=None)`**：
   - 用途：返回一个包含具有名称的所有捕获组的字典。
   - 参数：可选参数，用于指定当没有匹配时的默认值。
   - 返回值：返回一个包含具有名称的所有捕获组的文本的字典，如果没有匹配，返回指定的默认值。

   示例：
   ```python
   import re
   pattern = re.compile(r'(?P<day>\d{2})-(?P<month>\d{2})-(?P<year>\d{4})')
   match = pattern.search("Date: 12-31-2022")
   group_dict = match.groupdict()
   day = group_dict['day']
   month = group_dict['month']
   year = group_dict['year']
   ```

这些属性和方法使你能够轻松地访问和操作匹配对象中的不同部分，特别是当你的正则表达式包含多个捕获组时，它们非常有用。你可以通过索引或名称访问具体的分组，并获取它们的文本内容。



### 什么是 group(0) ?

> group()  和  group(0) 的效果一样

`group(0)` 是正则表达式匹配对象中的一个方法，用于**获取整个匹配的文本**。在正则表达式匹配中，捕获组编号从1开始，`group(0)` 表示整个模式的匹配。这是非常有用的，因为它允许你访问匹配的全文。

举个例子，假设你有一个正则表达式模式如下：

```python
import re

pattern = re.compile(r'(\d{2})-(\d{2})-(\d{4})')
match = pattern.search("Date: 12-31-2022")
```

在这个例子中，如果你想获取整个匹配的文本（"12-31-2022"），你可以使用 `group(0)` 方法：

```python
full_match = match.group(0)
```

`full_match` 将包含整个匹配的文本。与之对应的是 `group(1)`、`group(2)`、`group(3)`，它们分别代表第一个、第二个和第三个捕获组的文本。

总之，`group(0)` 是获取整个匹配的文本的方法，它非常有用，尤其当你需要整个匹配的文本时。



### 讲一下捕获组（groups）

> 这不是正则表达式的通用内容，而是 python 特有的方法

正则表达式模式串 `r'(?P<day>\d{2})-(?P<month>\d{2})-(?P<year>\d{4})'` 用于匹配日期字符串，并使用了**命名捕获组**。让我解释这个模式的各个部分：

- `r`：这是一个原始字符串标识，告诉Python不要对字符串中的反斜杠进行转义处理，这在正则表达式中很常见，以避免不必要的转义。

- `(?P<day>\d{2})`：这是一个捕获组，使用 `(?P<name>pattern)` 的语法定义。它包括以下部分：
  - `(?P<day>`：这是命名捕获组的开始标志，`day` 是捕获组的名称。
  - `\d{2}`：这是一个用于匹配两位数字的子模式。`\d` 表示匹配任意数字字符，`{2}` 表示匹配两次。
  - `)`：捕获组的结束标志。

- `-`：这是一个普通字符，用于匹配日期中的横杠。

- `(?P<month>\d{2})`：类似于第一个捕获组，它匹配月份的两位数字，并使用 `month` 作为捕获组的名称。

- `-`：日期中的横杠。

- `(?P<year>\d{4})`：这是最后一个捕获组，匹配四位年份，并使用 `year` 作为捕获组的名称。

所以，这个正则表达式模式串的目的是匹配日期字符串，例如 "01-12-2023"，并使用命名捕获组来提取日期中的日、月和年，使得你可以通过捕获组名称来访问这些部分的值。