# 面向对象

## 学习路线

学习Java面向对象编程需要经过一系列的步骤和概念，以下是一个基本的学习路线，它可以帮助您逐步建立对Java面向对象编程的理解和技能：

1. **Java基础**：
   - 开始学习Java的基本语法，包括变量、数据类型、运算符、控制结构（if、for、while等）等。
   - 熟悉Java的输入输出（I/O）操作，包括`System.out`和`Scanner`类的使用。
   - 学习异常处理机制，包括`try-catch`块的使用。

2. **面向对象基础**：
   - 理解面向对象编程的基本概念，如类、对象、封装、继承和多态。
   - 学习如何创建和使用类，包括类的成员变量和方法。
   - 掌握构造函数的概念和用法。

3. **类和对象**：
   - 学习如何创建自定义的Java类，包括类的属性和方法。
   - 掌握如何创建对象，并通过对象来调用类的方法和访问属性。
   - 理解封装的概念，使用访问修饰符（public、private、protected等）来控制成员的可见性。

4. **继承与多态**：
   - 学习继承的概念和语法，创建子类并扩展父类的功能。
   - 掌握多态的概念，使用方法重写（override）和方法重载（overload）来实现多态性。
   - 理解抽象类和接口的作用和使用。

5. **集合框架**：
   - 学习Java集合框架，包括列表（List）、集合（Set）、映射（Map）等数据结构。
   - 掌握不同集合类型的特点和用途，如ArrayList、HashSet、HashMap等。
   - 学习如何迭代集合和进行常见的集合操作。

6. **异常处理和文件操作**：
   - 进一步学习异常处理，包括自定义异常类和异常处理的最佳实践。
   - 学习文件操作，包括读取和写入文本文件、序列化和反序列化对象等。

7. **多线程编程**：
   - 理解多线程编程的概念和优点。
   - 学习如何创建和管理线程，使用关键字`Thread`和`Runnable`。
   - 掌握线程同步和互斥的方法，避免竞态条件和死锁。

8. **图形用户界面（GUI）编程**（可选）：
   - 学习如何使用Swing或JavaFX等库创建图形用户界面。
   - 开发简单的窗口应用程序，掌握事件处理和用户界面设计。

9. **持续学习和项目实践**：
   - 阅读Java相关的书籍、教程和文档，深入学习Java的高级特性和最佳实践。
   - 参与项目或编写自己的小型应用程序，将学到的知识应用到实际项目中。

10. **深入领域**：
    - 根据兴趣和需求，学习特定领域的Java开发，如Web开发（使用Servlet、JSP、Spring等框架）、移动应用开发（Android）、大数据处理（Hadoop、Spark）等。

11. **测试和调试**：
    - 学习如何编写单元测试，使用JUnit等测试框架。
    - 掌握调试技巧，使用IDE工具进行代码调试和分析。

12. **版本控制和团队协作**：
    - 学习使用版本控制系统（如Git）来管理代码。
    - 掌握团队协作工具和最佳实践，参与团队项目。

13. **继续学习和跟踪发展**：
    - Java技术不断发展，持续学习新的语言特性和工具，保持更新。



## 变量

- 使用 `static` 修饰    -->   类变量
- 无 `static ` 修饰   -->  实例变量



## 方法

--------

### 类方法

- 使用 `static` 修饰，可以互相调用类方法，在引入实例对象的情况下可以调用实例方法
- 一定用不到 `this` 指针



### 实例方法

- 无 `static` 修饰，可以调用实例方法和类方法，使用**实例相关的变量和方法**必须用this指针指代自己这个实例



### 构造方法

- 构造方法名必须和类名相同
- 没有方法值修饰词，因为一定返回**一个实例对象的引用**
- 必须用 `public` 修饰
- 使用**实例变量**和**实例方法**的时候，使用 `this` 指针；使用**类变量**和**类方法**的时候，一定不要用 `this` (可能不会报错，但是请保持语义)



## 继承

> **访问修饰符**

 继承和访问修饰符在 Java 中密切相关，因为它们用于控制子类对父类的属性和方法的访问权限。以下是继承和访问修饰符之间的关系：

1. **`public` 访问修饰符**：如果一个成员（字段或方法）在父类中被声明为 `public`，那么它可以被子类访问。子类可以继承并直接使用父类的 `public` 成员，无需额外的权限。这使得 `public` 成员在整个继承层次结构中都是可见的。

2. **`protected` 访问修饰符**：当一个成员在父类中被声明为 `protected` 时，它只能被同一个包中的类和子类访问。这意味着子类可以继承并访问父类的 `protected` 成员，但在不同包中的非子类无法访问。

3. **默认（包内可见）访问修饰符**：如果一个成员没有显式指定任何访问修饰符（也就是没有 `public`、`protected` 或 `private`），它将具有默认（包内可见）访问权限。这意味着它只能被同一个包中的类访问，而不能被不同包中的类或子类访问。

4. **`private` 访问修饰符**：`private` 访问修饰符用于将一个成员封装在类的内部，防止外部类和子类直接访问。`private` 成员不能被继承，因此子类无法直接访问父类的 `private` 成员。通常，`private` 成员的访问权限只限于父类的内部方法。

总结来说，访问修饰符的作用是：

- `public`：允许在任何地方访问。
- `protected`：允许子类和同一包内的类访问。
- 默认（包内可见）：允许同一包内的类访问。
- `private`：只允许在当前类内访问。

继承允许子类继承父类的属性和方法，但访问修饰符控制了这些继承成员的可见性。这种组合使得可以对父类的成员进行有选择性的封装，以确保只有具有适当权限的类可以访问它们。这有助于实现封装和信息隐藏的原则，增强了代码的安全性和可维护性。



> **继承的特点**

在 Java 中，继承是一种面向对象编程的核心概念，它允许一个类（子类）继承另一个类（父类）的属性和方法。继承是为了实现代码重用和创建类层次结构而引入的。以下是关于 Java 继承的一些重要概念和用法：

1. **继承关系**：在继承中，有两个主要角色：父类（超类或基类）和子类。子类继承了父类的属性和方法。子类可以添加额外的属性和方法，也可以重写父类的方法。

2. **关键字 `extends`**：在 Java 中，使用 `extends` 关键字来建立继承关系。子类声明中通过 `extends` 关键字指定父类。例如：
   
   ```java
   class Parent {
       // 父类的属性和方法
   }
   
   class Child extends Parent {
       // 子类的属性和方法
   }
   ```

3. **访问修饰符**：继承中，访问修饰符用于控制子类对父类的属性和方法的访问权限。常见的修饰符包括 `public`、`protected`、`default` 和 `private`。子类可以访问父类的 `public` 和 `protected` 成员，但不能访问 `private` 成员。

4. **方法重写**：子类可以重写父类的方法，以实现自己的行为。重写的方法在子类中使用相同的方法名、参数列表和返回类型。使用 `@Override` 注解可以帮助编译器检测是否正确重写了父类的方法。

   ```java
   class Parent {
       void sayHello() {
           System.out.println("Hello from Parent");
       }
   }

   class Child extends Parent {
       @Override
       void sayHello() {
           System.out.println("Hello from Child");
       }
   }
   ```

5. **super 关键字**：`super` 关键字用于在子类中调用父类的构造方法或方法。它可以帮助区分子类和父类中同名的属性或方法。

   ```java
   class Child extends Parent {
       Child() {
           super(); // 调用父类的构造方法
       }

       void doSomething() {
           super.sayHello(); // 调用父类的方法
       }
   }
   ```

6. **多继承**：Java 不支持多继承，一个类只能继承一个父类。但是，一个类可以实现多个接口，从而实现多继承的效果。

7. **构造方法的继承**：构造方法不会被继承，但子类的构造方法可以调用父类的构造方法，以确保父类的初始化工作得以完成。

继承是 Java 面向对象编程中的一个重要概念，它促进了代码重用和构建复杂类层次结构的能力。通过合理使用继承，可以减少代码冗余并提高代码的可维护性。然而，要小心避免过度继承，以避免复杂性和耦合度的增加。



## 接口



在 Java 中，接口是一种重要的概念，用于定义一组方法的规范，而没有提供方法的具体实现。接口允许类实现这些方法，以便符合接口的合同。接口的主要用途包括：

1. **定义规范**：接口用于定义一组方法，这些方法的签名在实现类中需要被具体实现。这提供了一种标准的方法，以确保实现类遵循相同的规范。

2. **实现多继承**：Java 不支持多继承，但一个类可以实现多个接口。这意味着一个类可以从多个接口继承方法规范，从而实现多继承的效果。

下面是如何定义和使用接口的一些基本示例：

```java
// 定义一个接口
interface MyInterface {
    void doSomething();              // 默认是公共的，不需要修饰词
    int calculate(int a, int b);
}

// 实现接口的类
class MyClass implements MyInterface {
    @Override
    public void doSomething() {
        System.out.println("Doing something.");
    }

    @Override
    public int calculate(int a, int b) {
        return a + b;
    }
}

public class Main {
    public static void main(String[] args) {
        MyInterface obj = new MyClass(); // 创建接口对象，但引用的是实现类的实例
        obj.doSomething();
        int result = obj.calculate(5, 3);
        System.out.println("Result: " + result);
    }
}
```

在上述示例中，我们首先定义了一个名为 `MyInterface` 的接口，它包含两个方法。然后，我们创建了一个实现了这个接口的类 `MyClass`，并在这个类中提供了方法的具体实现。最后，在 `Main` 类中，我们创建了一个接口对象并用它来调用实现类的方法。

接口常用于以下情况：

- 定义一组共享方法，以确保类在不同上下文中都能使用相同的方法。
- 定义回调机制，允许类实现某个接口以响应事件或动作。
- 实现多态，允许不同的类实现相同的接口，从而可以在通用上下文中使用它们。

请注意，接口中的方法默认是**公共的**（`public`），因此实现类必须将这些方法声明为 `public` 并提供具体的实现。如果实现类未提供方法的具体实现，将导致编译错误。



**特点**：

- 接口内部只能有**抽象方法**和**静态方法**
- 一个类实现接口的时候，要重写接口的所有的**抽象方法**





## 抽象类

Java 的抽象类（Abstract Class）是一种特殊的类，它不能被实例化，而只能用作其他类的基类（父类）。抽象类允许你定义一些抽象方法，这些方法在抽象类中没有具体的实现，而是要求继承该抽象类的子类来提供具体的实现。抽象类通常用于创建类层次结构，并在其中提供一些通用的方法和属性。

以下是关于 Java 抽象类的一些重要概念和规则：

1. **声明抽象类**：要声明一个抽象类，使用 `abstract` 关键字来修饰类的定义。例如：
   
   ```java
   abstract class Shape {
       // 可以包含实例变量和具体方法
   }
   ```

2. **抽象方法**：抽象类可以包含抽象方法，这些方法没有实际的实现。抽象方法使用 `abstract` 关键字来修饰方法的定义，而不包含方法体。子类必须提供具体的实现来重写这些抽象方法。

   ```java
   abstract class Shape {
       abstract double area(); // 抽象方法
   }
   ```

3. **实例变量和方法**：抽象类可以包含实例变量和具体方法，不仅仅局限于抽象方法。这些方法和变量可以被子类继承和访问。

4. **继承**：子类通过使用 `extends` 关键字继承抽象类。子类必须提供具体实现来重写抽象类中的抽象方法。如果子类未提供实现，那么子类也必须声明为抽象类。

   ```java
   class Circle extends Shape {
       double radius;

       Circle(double radius) {
           this.radius = radius;
       }

       @Override
       double area() {
           return Math.PI * radius * radius;
       }
   }
   ```

5. **抽象类的实例化**：抽象类不能被实例化，也就是不能用 `new` 关键字创建抽象类的对象。但可以通过创建抽象类的非抽象子类的对象来实例化。

抽象类的主要目的是提供一个通用的类模板，以便其他类可以继承它并提供特定的实现。抽象类通常用于定义一组相关的类，确保它们共享一些通用的特性，同时留下一些具体实现需要子类提供。这有助于提高代码的可维护性和扩展性。



## 多态

> **抽象类**和**接口**是面向对象语言多态体现的重要方面



