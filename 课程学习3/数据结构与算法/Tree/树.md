# 树

## 前言

树（Tree）是一种重要的数据结构，广泛应用于计算机科学和编程领域。以下是有关树的一份知识清单，包括基本概念、常见类型和相关术语：

1. **树的基本概念**：
   - **节点（Node）**：树的基本构建单元，可以包含数据和指向其他节点的引用。
   - **根节点（Root）**：树的顶层节点，是树的入口点。
   - **叶子节点（Leaf Node）**：没有子节点的节点。
   - **父节点（Parent Node）**：拥有子节点的节点。
   - **子节点（Child Node）**：直接连接到父节点的节点。
   - **深度（Depth）**：节点到根节点的层次距离。
   - **高度（Height）**：树的最大深度。
2. **常见类型的树**：
   - **二叉树（Binary Tree）**：每个节点最多有两个子节点。
   - **二叉搜索树（Binary Search Tree，BST）**：一种二叉树，左子树的值小于父节点，右子树的值大于父节点。
   - **平衡二叉树（Balanced Binary Tree）**：确保树的高度平衡，提高查找性能。
   - **堆（Heap）**：一种特殊的树结构，用于优先队列。
   - **B树和B+树**：用于数据库和文件系统的高效存储结构。
   - **红黑树（Red-Black Tree）**：一种自平衡二叉搜索树，确保树的高度平衡。
   - **Trie树（字典树）**：用于字符串搜索和字典存储。
3. **树的遍历**：
   - **前序遍历（Preorder Traversal）**：先访问根节点，然后按左子树、右子树的顺序遍历。
   - **中序遍历（Inorder Traversal）**：按左子树、根节点、右子树的顺序遍历。
   - **后序遍历（Postorder Traversal）**：先遍历左子树、右子树，最后访问根节点。
   - **层次遍历（Level Order Traversal）**：逐层遍历树，从上到下，从左到右。
4. **树的应用**：
   - 数据存储：数据库索引、文件系统、内存管理。
   - 图算法：寻找最短路径、生成最小生成树等。
   - 表达层次关系：组织结构、家谱、文件目录结构。
   - 搜索和排序：二叉搜索树用于排序和搜索。
   - 编程练习：树结构常用于编程面试和竞赛中的问题。
5. **树的复杂性**：
   - 树的操作复杂度取决于树的类型和平衡性。
   - 二叉搜索树在最坏情况下可能退化成链表，导致O(n)复杂度。
   - 平衡树可以确保O(log n)的复杂度，如AVL树和红黑树。
6. **树的扩展**：
   - **多叉树（N-ary Tree）**：每个节点可以有多于两个的子节点。
   - **树的序列化和反序列化**：将树转换为可存储或传输的格式，然后还原为原始树结构。





## 二叉树

------

### 一个简介

我们从二叉树（Binary Tree）开始学习。二叉树是一种树状数据结构，每个节点最多有两个子节点：**左子节点**和**右子节点**。以下是关于二叉树的基本概念和操作：

1. **基本概念**：
   - **节点（Node）**：树的基本构建单元，包含数据和指向左子节点和右子节点的引用。
   - **根节点（Root）**：二叉树的顶层节点，是树的入口点。
   - **叶子节点（Leaf Node）**：没有子节点的节点，即左子节点和右子节点都为空。
   - **父节点（Parent Node）**：拥有子节点的节点。
   - **左子节点（Left Child）**：根节点的左侧子节点。
   - **右子节点（Right Child）**：根节点的右侧子节点。
   - **深度（Depth）**：节点到根节点的层次距离。
   - **高度（Height）**：树的最大深度，即从根节点到最深叶子节点的距离。
   - **度（degree）**：我们约定是每个节点的**出度**，我们默认树是一个**有向图**，**树的度**是所有节点度的**最大值**
   - 满二叉树：全部都满了
   - 完全二叉树：
2. **二叉树的常见操作**：
- **插入节点**：将新节点插入二叉树中，通常按照规则（例如，小于根节点的值放在左子树，大于根节点的值放在右子树）来确定插入位置。
  
- **查找节点**：按照某种规则（通常是二叉搜索树规则）查找包含特定值的节点。
  
- **删除节点**：从二叉树中删除包含特定值的节点，并重新组织树结构以保持二叉树的性质。
3. **二叉树的种类**：

   - **二叉搜索树（Binary Search Tree，BST）**：一种二叉树，它满足左子树的值都小于根节点，右子树的值都大于根节点。这种结构使得查找和插入操作非常高效。
   - **平衡二叉树（Balanced Binary Tree）**：确保树的高度平衡，以防止二叉搜索树退化为链表。常见的平衡树包括AVL树和红黑树。
4. **遍历二叉树**：

   - **前序遍历（Preorder Traversal）**：先访问根节点，然后按左子树、右子树的顺序遍历。
   - **中序遍历（Inorder Traversal）**：按左子树、根节点、右子树的顺序遍历，这种遍历方式在二叉搜索树中得到有序结果。
   - **后序遍历（Postorder Traversal）**：先遍历左子树、右子树，最后访问根节点。
   - **层次遍历（Level Order Traversal）**：逐层遍历树，从上到下，从左到右。

二叉树是理解更复杂树结构的基础，也是许多常见算法和数据结构的基础。



### 二叉树的线索化

二叉树的线索化（Threaded Binary Tree）是一种用于改进二叉树的遍历效率的技术。在标准的二叉树结构中，遍历（如中序遍历）通常需要使用递归或栈来跟踪节点的顺序。线索化二叉树通过添加线索（或者称为线索化）到二叉树的节点上，允许你更高效地进行遍历，尤其是中序遍历。

线索化二叉树中，每个节点都包含两个额外的指针（线索）：
1. **前驱线索**：指向节点在中序遍历中的前一个节点。
2. **后继线索**：指向节点在中序遍历中的后一个节点。

线索化可以大大减少遍历二叉树时所需的空间和时间开销，因为你可以直接跳到下一个节点，而无需使用递归或栈。

线索化二叉树的构建通常有两种方法：
1. **中序线索二叉树**：这是最常见的线索化方法，其中所有节点都被线索化，使中序遍历更高效。
2. **前序线索二叉树**：在这种情况下，所有节点都被线索化，以支持前序遍历。

线索化二叉树通常在特定应用中使用，其中需要频繁的中序或前序遍历，并且希望提高性能。一些常见的应用包括数据库系统中的B树索引、图形渲染中的几何计算等。线索化二叉树的主要优点是减少了递归或栈的使用，从而节省了内存空间和降低了时间复杂度。然而，线索化二叉树的构建和维护需要额外的工作，可能增加了代码的复杂性。



构建中序线索二叉树：

```cpp
```

构建前序线索二叉树：

```cpp
```





### 二叉树一些技巧

二叉树有一些公式和相关的计数技巧，这些分析方法有些到了**树和图**中也一样适用（请学习**图论**）



1. 计数相关：

    > 二叉树是一个度数为 $2$ 的有向图

    **设节点数 $n$, 度数 $d$, 度数为$0, 1, 2$ 的节点数量分别为$n_0, n_1, n_2$**
    $$
    \begin{align}
    	& d = 2n_2+n_1  \qquad   \\ 
    	& n = d + 1     \qquad (树的性质)   \\
    	& n = n_2+n_1+n_0 \qquad \\
    \end{align}
    $$
    由上面的基础式子，可以得到一个推论：**叶子节点的数量为度数为2的节点的数量加一** 
    $$
    n_0 = n_2 + 1
    $$
    
    **问题：n个节点，有多少不同的二叉树？**
    $$
    b_n = \frac{1}{n+1} \cdot \mathbf{C}_{2n}^n
    $$
    卡特兰数，使用递推的方法或者**生成函数**的方法



2. 还原二叉树的方法

    >前序遍历 + 中序遍历 可以唯一确定一棵二叉树
    >
    >```cpp
    >// hdu 1710 的部分代码
    >int pre[N];
    >int in[N];
    >int post[N];
    >void build_tree(node* &root,int l,int r,int &t)  //以引用作为形参
    >{
    >    int index = -1;
    >    // 先序遍历的第一个肯定为根
    >    for(int i=l;i<=r;++i)
    >    {
    >        if(in[i]==pre[t])
    >        {
    >            index = i;
    >            break;
    >        }
    >    }
    >    if(index==-1)   return;  // 回溯
    >    else
    >    {
    >        ++t;
    >        root = new node;
    >        root->value = in[index];
    >        root->l = root->r = NULL;
    >        if(index>l) build_tree(root->l,l,index-1,t);
    >        if(index<r) build_tree(root->r,index+1,r,t);
    >        return;
    >    }
    >}
    >```
    >
    >
    >
    >后序遍历 + 中序遍历 可以唯一确定一棵二叉树
    >
    >```cpp
    >// 核心代码
    >void BuildTreeByInAndPost(BiTree &tr, int l, int r, int &cur){
    >    // 递归建树 , 调用方式 BuildTreeByInAndPost(T, 0, n-1, cur) 其中 cur初始化为 n-1,因为后序遍历需要从后面找根节点
    >    if(cur<0)return;  // 边界条件
    >    int idx = -1;
    >    for(int i=l;i<=r;++i){
    >        if(in[i]==post[cur]){
    >            idx = i;
    >            break;
    >        }
    >    }
    >    if(idx==-1)return;   // 没找到
    >    tr = new node;
    >    tr->ls = tr->rs = NULL;
    >    tr->data = in[idx];
    >    // 递归建树 , 先右儿子，再左儿子，因为这是后序遍历
    >    --cur;
    >    if(idx<r) BuildTreeByInAndPost(tr->rs, idx+1, r, cur);
    >    if(idx>l) BuildTreeByInAndPost(tr->ls, l, idx-1, cur);
    >}
    >```
    >
    >
    >
    >层序遍历 + 中序遍历 可以唯一确定一棵二叉树 (**要求没有重复元素**！)
    >
    >```cpp
    >```
    >
    >
    >
    >





### 关于二叉树的一些题目（笔试题）





## 树与森林

-------

### 前言

树更加一般，是DAG的一种，我们经常使用**拓扑排序**和**树形DP**

森林由多棵树构成



> [树、森林、二叉树的相互转换](https://blog.csdn.net/weixin_43848614/article/details/106241176)



